#include "HTTPRequest.hpp"
#include <sstream>
#include <algorithm>

HTTPRequest::HTTPRequest() {
}

HTTPRequest::~HTTPRequest() {
}

bool HTTPRequest::isChunked() const {
    std::map<std::string, std::string>::const_iterator it = headers.find("Transfer-Encoding");
    if (it != headers.end()) {
        std::string value = it->second;
        // Convertiamo in minuscolo per evitare problemi di case-sensitive
        std::transform(value.begin(), value.end(), value.begin(), ::tolower);
        return (value.find("chunked") != std::string::npos);
    }
    return false;
}
// --- rawRequest: stringa contenente la richiesta HTTP ( *presumibilmente* ) ---
void HTTPRequest::parseRequest(const std::string &rawRequest) {
    // Cerca la fine degli header: "\r\n\r\n"
    std::size_t pos = rawRequest.find("\r\n\r\n");
    if (pos == std::string::npos) {
        // Qui, in un'applicazione reale, potresti decidere di attendere altri dati.
        // Per ora, usciamo dalla funzione o segnaliamo un errore.
        return;
    }
    // La parte degli header termina in pos + 4
    std::string headerPart = rawRequest.substr(0, pos);
    // Il body (se presente) inizia dopo "\r\n\r\n"
    std::string bodyPart = rawRequest.substr(pos + 4);

    // --- Parsing della Request Line ---
    // La prima linea degli headerPart è la request line
    std::istringstream headerStream(headerPart);
    std::string requestLine;
    std::getline(headerStream, requestLine);
    if (requestLine.back() == '\r')
        requestLine.pop_back();  // rimuovi il \r finale se presente

    std::istringstream requestLineStream(requestLine);
    requestLineStream >> method >> uri >> httpVersion;

    // --- Parsing degli Header ---
    std::string line;
    while (std::getline(headerStream, line)) {
        if (line.empty() || line == "\r")
            continue;
        // Rimuovi il \r finale, se presente
        if (!line.empty() && line.back() == '\r')
            line.pop_back();

        // Cerca il separatore ":"
        std::size_t colonPos = line.find(":");
        if (colonPos != std::string::npos) {
            std::string key = line.substr(0, colonPos);
            std::string value = line.substr(colonPos + 1);
            // Rimuovi spazi iniziali e finali
            key.erase(0, key.find_first_not_of(" \t"));
            key.erase(key.find_last_not_of(" \t") + 1);
            value.erase(0, value.find_first_not_of(" \t"));
            value.erase(value.find_last_not_of(" \t") + 1);
            headers[key] = value;
        }
    }

    // --- Body ---
    // Se è presente un header Content-Length, assicuriamoci di avere quel numero di byte
    std::map<std::string, std::string>::iterator it = headers.find("Content-Length");
    if (it != headers.end()) {
        int contentLength = std::atoi(it->second.c_str());
        // Se il body letto è inferiore a Content-Length, in una implementazione reale, 
        // attendi ulteriori dati. Per ora, assumiamo che rawRequest contenga tutto.
        if (static_cast<int>(bodyPart.size()) >= contentLength)
            body = bodyPart.substr(0, contentLength);
        else
            body = bodyPart;  // oppure gestire l'errore
    } else if (isChunked()) {
        // Se la richiesta è chunked, bisogna implementare il parsing dei chunk
        // Per ora, potresti salvare l'intero body e implementare il parsing chunked in seguito
        body = bodyPart;
        // In seguito, decodificherai il body chunked in una funzione apposita
    } else {
        // Altrimenti, assegna il body (se presente) così com'è
        body = bodyPart;
    }
}
#include "HTTPResponse.hpp"
#include <sstream>
#include <string>

HTTPResponse::HTTPResponse() : httpVersion("HTTP/1.1"), statusCode(200), statusMessage("OK") {
    // init settings: e.s. aggiungere "header standard" (Content-Type: text/html)
    headers["Content-Type"] = "text/html";
}

HTTPResponse::~HTTPResponse() {
    // If/When neccessary, 2 free resources
}

void HTTPResponse::setStatus(int code, const std::string &message) {
    statusCode = code;
    statusMessage = message;
}

void HTTPResponse::setHeader(const std::string &key, const std::string &value) {
    headers[key] = value;
}

std::string HTTPResponse::toString() const {
    std::ostringstream oss;
    // Ccompose/ or Build Status-Line
    oss << httpVersion << " " << statusCode << " " << statusMessage << "\r\n";
    // Add headers
    for (std::map<std::string, std::string>::const_iterator it = headers.begin();
         it != headers.end(); ++it) {
        oss << it->first << ": " << it->second << "\r\n";
    }
    // header terinator with "\r\n"
    oss << "\r\n";
    // Add body
    oss << body;
    return oss.str();
}
#include "HTTPServer.hpp"
#include "HTTPRequest.hpp"
#include "HTTPResponse.hpp"

#include <sstream>
#include <iostream>
#include <stdexcept>
#include <unistd.h>
#include <fcntl.h>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <poll.h>

// #including libraries /headers for socket programming
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>

HTTPServer::HTTPServer(const Config &config) : _config(config) {
    // Init degli socket in base alla configurazione
    initSockets();
}

HTTPServer::~HTTPServer() {
    // Close * i socket di ascolto
    for (size_t i = 0; i < _listenSockets.size(); ++i) {
        close(_listenSockets[i]);
    }
}

void HTTPServer::initSockets() {
    // Per ogni **ServerConfig**, crea un socket e configuralo in modalità "non bloccante".
    // Se nel file di configurazione hai più server, vanno gestite eventuali duplicazioni di host:port (like subject specifies: il primo per **host:port** è quello di default).
    for (size_t i = 0; i < _config.servers.size(); ++i) {
        const ServerConfig &server = _config.servers[i];

        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0)
            throw std::runtime_error("Errore nella creazione del socket.");

        // Configura il socket in modalità non bloccante e imposta FD_CLOEXEC
        int flags = fcntl(sockfd, F_GETFL, 0);
        if (flags < 0)
            throw std::runtime_error("Errore in fcntl F_GETFL");
        if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) < 0)
            throw std::runtime_error("Errore in fcntl F_SETFL");

        // Configura l'indirizzo
        sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(server.listen);
        addr.sin_addr.s_addr = INADDR_ANY;  // Per semplicità possiamo gestire host specifici in base a server.host 
                                            //(if server.host == "a specific host") do something specific {else} if(server.host == "a specific host") do something else
        memset(addr.sin_zero, 0, sizeof(addr.sin_zero));

        // Lega il socket
        if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(sockfd);
            throw std::runtime_error("Errore nel binding del socket.");
        }

        // Inizia ad ascoltare
        if (listen(sockfd, 128) < 0) {
            close(sockfd);
            throw std::runtime_error("Errore in listen().");
        }

        _listenSockets.push_back(sockfd);
        std::cout << "Server in ascolto su porta " << server.listen << std::endl;
    }
}

void HTTPServer::handleClientRequest(int client_fd, const std::string &rawRequest) {
    // 1. Creo un "oggetto" per il parsing della richiesta
    HTTPRequest request;
    request.parseRequest(rawRequest);

    // 2. Costruisco una risposta di base
    HTTPResponse response;
    response.setStatus(200, "OK");
    response.setHeader("Content-Type", "text/html");
    
    // response example: pagina HTML statica
    response.body = "<html><body><h1>Ciao, Mondo!</h1></body></html>";
    
    // set the **Content-Length** (C++98 usa std::ostringstream per la conversione)
    std::ostringstream oss;
    oss << response.body.size();
    response.setHeader("Content-Length", oss.str());

    // Ottieni la stringa completa della risposta
    std::string responseStr = response.toString();

    // Sendind the response... (Hopefully:)
    ssize_t sent = write(client_fd, responseStr.c_str(), responseStr.size());
    if (sent < 0) {
        std::cerr << "Errore in write(): " << strerror(errno) << std::endl;
    }

    // After sending the response , closing the connection (***Va gestito keep-alive?***)
    close(client_fd);
}

void HTTPServer::eventLoop() {
    // Qui utilizzare poll() (or equal func) per gestire le I/O su:
    // - Socket di ascolto*
    // - Connessioni attive*
    // 1. Costruire una struttura (ad esempio std::vector<pollfd>) per gestire eventi di lettura e scrittura.

    // Ad es.:

    std::vector<pollfd> pollfds;
    // Aggiungi i socket di ascolto a pollfds
    for (size_t i = 0; i < _listenSockets.size(); ++i) {
        pollfd pfd;
        pfd.fd = _listenSockets[i];
        pfd.events = POLLIN;
        pfd.revents = 0;
        pollfds.push_back(pfd);
    }
    
    std::cout << "Inizio del loop degli eventi..." << std::endl;

    while (true)
    {
        int ret = poll(&pollfds[0], pollfds.size(), -1);
        if (ret < 0)
        {
            std::cerr << "Errore in poll(): " << strerror(errno) << std::endl;
            continue;
        }
        // Gestire gli eventi: se uno dei socket di ascolto è pronto, accetta nuove connessioni,
        // altrimenti gestire le connessioni esistenti.

        // Itera sui pollfd per verificare quali sono pronti
        for (size_t i = 0; i < pollfds.size(); ++i)
        {
            if (pollfds[i].revents & POLLIN)
            {
                // Se il **socket è di ascolto**: **Accetta nuove connessioni**
                if (std::find(_listenSockets.begin(), _listenSockets.end(), pollfds[i].fd) != _listenSockets.end())
                {
                    // Accettiamo la connessione
                    sockaddr_in client_addr;
                    socklen_t client_len = sizeof(client_addr);
                    int client_fd = accept(pollfds[i].fd, (struct sockaddr*)&client_addr, &client_len);
                    if (client_fd < 0)
                    {
                        std::cerr << "Errore in accept(): " << strerror(errno) << std::endl;
                        continue;
                    }

                    // Imposta il socket del client in modalità non bloccante
                    int flags = fcntl(client_fd, F_GETFL, 0);
                    if (flags >= 0)
                    {
                        fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
                    }
                    
                    std::cout << "Nuova connessione accettata: fd " << client_fd << std::endl;

                    // Aggiungi il client alla lista dei pollfd per monitorarlo
                    struct pollfd client_pfd;
                    client_pfd.fd = client_fd;
                    client_pfd.events = POLLIN;  // Monitoriamo per lettura (richieste HTTP)
                    client_pfd.revents = 0;
                    pollfds.push_back(client_pfd);
                }
                else
                {
                    // Qui gestiresti la comunicazione con un client già connesso
                    // Ad esempio, leggere la richiesta HTTP
                    char buffer[1024];
                    ssize_t n = read(pollfds[i].fd, buffer, sizeof(buffer) - 1);
                    if (n <= 0)
                    {
                        if (n < 0)
                            std::cerr << "Errore in read(): " << strerror(errno) << std::endl;
                        else
                            std::cout << "Chiusura della connessione: fd " << pollfds[i].fd << std::endl;
                        close(pollfds[i].fd);
                        // Rimuovi il pollfd dalla lista
                        pollfds.erase(pollfds.begin() + i);
                        --i;
                    }
                    else
                    {
                        buffer[n] = '\0';
                        std::string rawRequest(buffer);
                        std::cout << "Ricevuto dal fd " << pollfds[i].fd << ": " << rawRequest << std::endl; /* Buffer -> rawRequest*/
                        
                        // chiamo handleClientRequest per processare la richiesta + inviare la risposta
                        handleClientRequest(pollfds[i].fd, rawRequest);
                    
                        // Rimuoviamo il client dalla lista; handleClientRequest ha chiuso il socket
                        pollfds.erase(pollfds.begin() + i);
                        --i;

                    }
                }
            }
        }
    }
}

void HTTPServer::run() {
    // Start loop degli eventi
    eventLoop();
}

// **La gestione del loop degli eventi, da subject:**
// Usare solamente poll() per gestire le I/O su socket. (gestire in modo non bloccante LETTURA e SCRITTURA)
// & Gestire eventuali errori senza terminare il server#include "Parser.hpp"
#include <cstdlib>
#include <stdexcept>
#include <iostream>

Parser::Parser() {}
Parser::~Parser() {}

Config Parser::parse(const std::string &configContent) {
    Config config;
    // Otteniamo la lista dei token
    Tokenizer tokenizer;
    std::vector<Token> tokens = tokenizer.tokenize(configContent);
    size_t pos = 0;
    while (pos < tokens.size()) {
        // Ci aspettiamo la direttiva "server"
        if (tokens[pos].value == "server") {
            ServerConfig server = parseServer(tokens, pos);
            config.servers.push_back(server);
        } else {
            // Se troviamo qualcosa che non è "server", può essere un commento o un errore
            pos++;
        }
    }
    return config;
}

void Parser::expectToken(const std::vector<Token> &tokens, size_t &pos, const std::string &expected) {
    if (pos >= tokens.size() || tokens[pos].value != expected) {
        throw std::runtime_error("Errore di parsing: ci si aspettava '" + expected + "' ma trovato '" +
                                 (pos < tokens.size() ? tokens[pos].value : "EOF") + "'");
    }
    pos++;
}

ServerConfig Parser::parseServer(const std::vector<Token> &tokens, size_t &pos) {
    ServerConfig server;
    // Ci aspettiamo "server"
    if (tokens[pos].value != "server") {
        throw std::runtime_error("Errore: direttiva 'server' attesa.");
    }
    pos++;
    // Aspettiamo '{'
    expectToken(tokens, pos, "{");

    // Leggiamo direttive fino a che non troviamo '}'
    while (pos < tokens.size() && tokens[pos].value != "}") {
        if (tokens[pos].value == "listen") {
            pos++;
            server.listen = std::atoi(tokens[pos].value.c_str());
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "host") {
            pos++;
            server.host = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "server_name") {
            pos++;
            server.server_name = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "error_page") {
            pos++;
            server.error_page = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "client_max_body_size") {
            pos++;
            server.client_max_body_size = static_cast<size_t>(std::atoi(tokens[pos].value.c_str()));
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "location") {
            // Gestiamo il blocco location
            pos++;
            // Il token successivo è il path della location
            LocationConfig location;
            location.path = tokens[pos].value;
            pos++;
            // Aspettiamo '{'
            expectToken(tokens, pos, "{");
            location = parseLocation(tokens, pos);
            server.locations.push_back(location);
        } else {
            // Se troviamo una direttiva sconosciuta, la saltiamo (oppure gestisci l'errore)
            std::cerr << "Direttiva sconosciuta nel blocco server: " << tokens[pos].value << std::endl;
            pos++;
        }
    }
    expectToken(tokens, pos, "}"); // Fine del blocco server
    return server;
}

LocationConfig Parser::parseLocation(const std::vector<Token> &tokens, size_t &pos) {
    LocationConfig location;
    // Inizializziamo alcuni valori di default
    location.autoindex = false;
    while (pos < tokens.size() && tokens[pos].value != "}") {
        if (tokens[pos].value == "root") {
            pos++;
            location.root = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "index") {
            pos++;
            // Potrebbe esserci più di un file index
            while (tokens[pos].value != ";") {
                location.index.push_back(tokens[pos].value);
                pos++;
            }
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "autoindex") {
            pos++;
            location.autoindex = (tokens[pos].value == "on");
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "methods") {
            pos++;
            // Leggiamo tutti i metodi fino al ';'
            while (tokens[pos].value != ";") {
                location.methods.push_back(tokens[pos].value);
                pos++;
            }
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "cgi") {
            pos++;
            location.cgi_extension = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else {
            std::cerr << "Direttiva sconosciuta nel blocco location: " << tokens[pos].value << std::endl;
            pos++;
        }
    }
    expectToken(tokens, pos, "}");
    return location;
}
#include "Tokenizer.hpp"
#include <cctype>
#include <sstream>

Tokenizer::Tokenizer() {}
Tokenizer::~Tokenizer() {}

bool Tokenizer::isSymbol(char c) const {
    return (c == '{' || c == '}' || c == ';');
}

bool Tokenizer::isWhitespace(char c) const {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

std::vector<Token> Tokenizer::tokenize(const std::string &content) {
    std::vector<Token> tokens;
    size_t i = 0;
    while (i < content.size()) {
        if (isWhitespace(content[i])) {
            i++;
            continue;
        }
        // Se è un simbolo
        if (isSymbol(content[i])) {
            Token token;
            token.type = TOKEN_SYMBOL;
            token.value = content[i];
            tokens.push_back(token);
            i++;
            continue;
        }
        // Se è una parola o un numero (token alfanumerico)
        size_t start = i;
        while (i < content.size() && !isWhitespace(content[i]) && !isSymbol(content[i])) {
            i++;
        }
        std::string word = content.substr(start, i - start);
        Token token;
        // Possiamo migliorare il riconoscimento: se tutti i caratteri sono numerici, possiamo definirlo come TOKEN_NUMBER.
        bool isNum = true;
        for (size_t j = 0; j < word.size(); j++) {
            if (!std::isdigit(word[j])) {
                isNum = false;
                break;
            }
        }
        token.type = (isNum ? TOKEN_NUMBER : TOKEN_WORD);
        token.value = word;
        tokens.push_back(token);
    }
    return tokens;
}
// #include "Parser.hpp"
// #include "HTTPServer.hpp"
// #include <fstream>
// #include <iostream>
// #include <sstream>

// std::string readFile(const std::string &filename) {
//     std::ifstream file(filename.c_str());
//     if (!file.is_open()) {
//         throw std::runtime_error("Impossibile aprire il file: " + filename);
//     }
//     std::stringstream buffer;
//     buffer << file.rdbuf();
//     return buffer.str();
// }

// int main(int argc, char **argv) {
//     std::string configPath = "config/default.conf"; // percorso di default
//     if (argc > 1) {
//         configPath = argv[1];
//     }

//     try {
//         std::string configContent = readFile(configPath);
//         Parser parser;
//         Config config = parser.parse(configContent);
//         // Stampa di debug: direttive lette
//         std::cout << "Numero di server configurati: " << config.servers.size() << std::endl;
//         for (size_t i = 0; i < config.servers.size(); i++) {
//             std::cout << "Server " << i+1 << ":\n";
//             std::cout << "\tListen: " << config.servers[i].listen << "\n";
//             std::cout << "\tHost: " << config.servers[i].host << "\n";
//             std::cout << "\tServer Name: " << config.servers[i].server_name << "\n";
//             std::cout << "\tError Page: " << config.servers[i].error_page << "\n";
//             std::cout << "\tClient Max Body Size: " << config.servers[i].client_max_body_size << "\n";
//             std::cout << "\tNumero di location: " << config.servers[i].locations.size() << "\n";
//         }
//         HTTPServer server(config);
//         server.run();

//     } catch (std::exception &e) {
//         std::cerr << "Errore: " << e.what() << std::endl;
//         return 1;
//     }
//     return 0;
// }
// #include "HTTPRequest.hpp"
// #include <iostream>
// #include <string>

// int main() {
//     // Esempio di richiesta HTTP semplice (no body)
//     std::string rawRequest =
//         // -- test GET -- Status: Ok
//         // "GET /index.html HTTP/1.1\r\n"
//         // "Host: www.example.com\r\n"
//         // "User-Agent: TestAgent/1.0\r\n"
//         // "Accept: text/html\r\n"
//         // "\r\n";

//         // -- test POST -- Status: Ok
//         // "POST /submit-form HTTP/1.1\r\n"
//         // "Host: www.example.com\r\n"
//         // "Content-Type: application/x-www-form-urlencoded\r\n"
//         // "Content-Length: 27\r\n"
//         // "\r\n"
//         // "field1=value1&field2=value2";
        
//         // -- test2 POST chunked -- Status: - ToDo: Decodifica del Chunked Transfer-Encoding:
//         "POST /upload HTTP/1.1\r\n"
//         "Host: www.example.com\r\n"
//         "Transfer-Encoding: chunked\r\n" // ToDo: Decodifica del Chunked Transfer-Encoding:
//         "\r\n"
//         "5\r\nHello\r\n0\r\n\r\n";

//     HTTPRequest request;
//     request.parseRequest(rawRequest);

//     // Stampa dei risultati
//     std::cout << "Metodo: " << request.method << std::endl;
//     std::cout << "URI: " << request.uri << std::endl;
//     std::cout << "HTTP Version: " << request.httpVersion << std::endl;

//     std::cout << "Headers:" << std::endl;
//     for (std::map<std::string, std::string>::const_iterator it = request.headers.begin();
//          it != request.headers.end(); ++it)
//     {
//         std::cout << "\t" << it->first << ": " << it->second << std::endl;
//     }

//     std::cout << "Body: " << request.body << std::endl;

//     return 0;
// }#include "HTTPResponse.hpp"
#include <iostream>
#include <sstream>

// Simple response tester
int main() {
    HTTPResponse response;

    // setting some personalized test headers
    response.setHeader("Content-Type", "text/plain");
    response.setHeader("Connection", "close");

    // test body response for C++98
    // response.body = "Hello, world!";
    // If we don't set "Content-Length", we can do it automatically 
    // {
    //     std::ostringstream oss;
    //     oss << response.body.size();
    //     response.setHeader("Content-Length", oss.str());
    // }
    response.setHeader("Content-Length", std::to_string(response.body.size())); /*Can't use this cause std::to_string doesn't exist on C++98 */


    // Printf final response
    // Printf final response
    std::cout << "Risposta HTTP generata:\n";
    std::cout << response.toString() << std::endl;

    return 0;
}
