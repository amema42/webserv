#include "HTTPServer.hpp"
#include <iostream>
#include <stdexcept>
#include <vector>
#include <cstring>
#include <cstdlib>
#include <poll.h>

// #including libraries /headers for socket programming
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>

HTTPServer::HTTPServer(const Config &config) : _config(config) {
    // Init degli socket in base alla configurazione
    initSockets();
}

HTTPServer::~HTTPServer() {
    // Close * i socket di ascolto
    for (size_t i = 0; i < _listenSockets.size(); ++i) {
        close(_listenSockets[i]);
    }
}

void HTTPServer::initSockets() {
    // Per ogni **ServerConfig**, crea un socket e configuralo in modalità "non bloccante".
    // Se nel file di configurazione hai più server, vanno gestite eventuali duplicazioni di host:port (like subject specifies: il primo per **host:port** è quello di default).
    for (size_t i = 0; i < _config.servers.size(); ++i) {
        const ServerConfig &server = _config.servers[i];

        int sockfd = socket(AF_INET, SOCK_STREAM, 0);
        if (sockfd < 0)
            throw std::runtime_error("Errore nella creazione del socket.");

        // Configura il socket in modalità non bloccante e imposta FD_CLOEXEC
        int flags = fcntl(sockfd, F_GETFL, 0);
        if (flags < 0)
            throw std::runtime_error("Errore in fcntl F_GETFL");
        if (fcntl(sockfd, F_SETFL, flags | O_NONBLOCK) < 0)
            throw std::runtime_error("Errore in fcntl F_SETFL");

        // Configura l'indirizzo
        sockaddr_in addr;
        addr.sin_family = AF_INET;
        addr.sin_port = htons(server.listen);
        addr.sin_addr.s_addr = INADDR_ANY;  // Per semplicità possiamo gestire host specifici in base a server.host 
                                            //(if server.host == "a specific host") do something specific {else} if(server.host == "a specific host") do something else
        memset(addr.sin_zero, 0, sizeof(addr.sin_zero));

        // Lega il socket
        if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            close(sockfd);
            throw std::runtime_error("Errore nel binding del socket.");
        }

        // Inizia ad ascoltare
        if (listen(sockfd, 128) < 0) {
            close(sockfd);
            throw std::runtime_error("Errore in listen().");
        }

        _listenSockets.push_back(sockfd);
        std::cout << "Server in ascolto su porta " << server.listen << std::endl;
    }
}

void HTTPServer::eventLoop() {
    // Qui utilizzare poll() (or equal func) per gestire le I/O su:
    // - Socket di ascolto*
    // - Connessioni attive*
    // 1. Costruire una struttura (ad esempio std::vector<pollfd>) per gestire eventi di lettura e scrittura.

    // Ad es.:

    std::vector<pollfd> pollfds;
    // Aggiungi i socket di ascolto a pollfds
    for (size_t i = 0; i < _listenSockets.size(); ++i) {
        pollfd pfd;
        pfd.fd = _listenSockets[i];
        pfd.events = POLLIN;
        pfd.revents = 0;
        pollfds.push_back(pfd);
    }
    
    std::cout << "Inizio del loop degli eventi..." << std::endl;

    while (true)
    {
        int ret = poll(&pollfds[0], pollfds.size(), -1);
        if (ret < 0)
            std::cerr << "Errore in poll(): " << strerror(errno) << std::endl;
            continue;
        // Gestire gli eventi: se uno dei socket di ascolto è pronto, accetta nuove connessioni,
        // altrimenti gestire le connessioni esistenti.

        // Itera sui pollfd per verificare quali sono pronti
        for (size_t i = 0; i < pollfds.size(); ++i)
        {
            if (pollfds[i].revents & POLLIN)
            {
                // Se il socket è di ascolto, accetta nuove connessioni
                if (std::find(_listenSockets.begin(), _listenSockets.end(), pollfds[i].fd) != _listenSockets.end())
                {
                    // Accettiamo la connessione
                    sockaddr_in client_addr;
                    socklen_t client_len = sizeof(client_addr);
                    int client_fd = accept(pollfds[i].fd, (struct sockaddr*)&client_addr, &client_len);
                    if (client_fd < 0)
                    {
                        std::cerr << "Errore in accept(): " << strerror(errno) << std::endl;
                        continue;
                    }

                    // Imposta il socket del client in modalità non bloccante
                    int flags = fcntl(client_fd, F_GETFL, 0);
                    if (flags >= 0)
                    {
                        fcntl(client_fd, F_SETFL, flags | O_NONBLOCK);
                    }
                    
                    std::cout << "Nuova connessione accettata: fd " << client_fd << std::endl;

                    // Aggiungi il client alla lista dei pollfd per monitorarlo
                    struct pollfd client_pfd;
                    client_pfd.fd = client_fd;
                    client_pfd.events = POLLIN;  // Monitoriamo per lettura (richieste HTTP)
                    client_pfd.revents = 0;
                    pollfds.push_back(client_pfd);
                }
                else
                {
                    // Qui gestiresti la comunicazione con un client già connesso
                    // Ad esempio, leggere la richiesta HTTP
                    char buffer[1024];
                    ssize_t n = read(pollfds[i].fd, buffer, sizeof(buffer) - 1);
                    if (n <= 0)
                    {
                        if (n < 0)
                            std::cerr << "Errore in read(): " << strerror(errno) << std::endl;
                        else
                            std::cout << "Chiusura della connessione: fd " << pollfds[i].fd << std::endl;
                        close(pollfds[i].fd);
                        // Rimuovi il pollfd dalla lista
                        pollfds.erase(pollfds.begin() + i);
                        --i;
                    }
                    else
                    {
                        buffer[n] = '\0';
                        std::cout << "Ricevuto dal fd " << pollfds[i].fd << ": " << buffer << std::endl;
                        // Qui dovresti inserire la logica per il parsing della richiesta HTTP
                        // e per la generazione della risposta
                    }
                }
            }
        }
    }
}

void HTTPServer::run() {
    // Start loop degli eventi
    eventLoop();
}

// **La gestione del loop degli eventi, da subject:**
// Usare solamente poll() per gestire le I/O su socket. (gestire in modo non bloccante LETTURA e SCRITTURA)
// & Gestire eventuali errori senza terminare il server#include "Parser.hpp"
#include <cstdlib>
#include <stdexcept>
#include <iostream>

Parser::Parser() {}
Parser::~Parser() {}

Config Parser::parse(const std::string &configContent) {
    Config config;
    // Otteniamo la lista dei token
    Tokenizer tokenizer;
    std::vector<Token> tokens = tokenizer.tokenize(configContent);
    size_t pos = 0;
    while (pos < tokens.size()) {
        // Ci aspettiamo la direttiva "server"
        if (tokens[pos].value == "server") {
            ServerConfig server = parseServer(tokens, pos);
            config.servers.push_back(server);
        } else {
            // Se troviamo qualcosa che non è "server", può essere un commento o un errore
            pos++;
        }
    }
    return config;
}

void Parser::expectToken(const std::vector<Token> &tokens, size_t &pos, const std::string &expected) {
    if (pos >= tokens.size() || tokens[pos].value != expected) {
        throw std::runtime_error("Errore di parsing: ci si aspettava '" + expected + "' ma trovato '" +
                                 (pos < tokens.size() ? tokens[pos].value : "EOF") + "'");
    }
    pos++;
}

ServerConfig Parser::parseServer(const std::vector<Token> &tokens, size_t &pos) {
    ServerConfig server;
    // Ci aspettiamo "server"
    if (tokens[pos].value != "server") {
        throw std::runtime_error("Errore: direttiva 'server' attesa.");
    }
    pos++;
    // Aspettiamo '{'
    expectToken(tokens, pos, "{");

    // Leggiamo direttive fino a che non troviamo '}'
    while (pos < tokens.size() && tokens[pos].value != "}") {
        if (tokens[pos].value == "listen") {
            pos++;
            server.listen = std::atoi(tokens[pos].value.c_str());
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "host") {
            pos++;
            server.host = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "server_name") {
            pos++;
            server.server_name = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "error_page") {
            pos++;
            server.error_page = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "client_max_body_size") {
            pos++;
            server.client_max_body_size = static_cast<size_t>(std::atoi(tokens[pos].value.c_str()));
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "location") {
            // Gestiamo il blocco location
            pos++;
            // Il token successivo è il path della location
            LocationConfig location;
            location.path = tokens[pos].value;
            pos++;
            // Aspettiamo '{'
            expectToken(tokens, pos, "{");
            location = parseLocation(tokens, pos);
            server.locations.push_back(location);
        } else {
            // Se troviamo una direttiva sconosciuta, la saltiamo (oppure gestisci l'errore)
            std::cerr << "Direttiva sconosciuta nel blocco server: " << tokens[pos].value << std::endl;
            pos++;
        }
    }
    expectToken(tokens, pos, "}"); // Fine del blocco server
    return server;
}

LocationConfig Parser::parseLocation(const std::vector<Token> &tokens, size_t &pos) {
    LocationConfig location;
    // Inizializziamo alcuni valori di default
    location.autoindex = false;
    while (pos < tokens.size() && tokens[pos].value != "}") {
        if (tokens[pos].value == "root") {
            pos++;
            location.root = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "index") {
            pos++;
            // Potrebbe esserci più di un file index
            while (tokens[pos].value != ";") {
                location.index.push_back(tokens[pos].value);
                pos++;
            }
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "autoindex") {
            pos++;
            location.autoindex = (tokens[pos].value == "on");
            pos++;
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "methods") {
            pos++;
            // Leggiamo tutti i metodi fino al ';'
            while (tokens[pos].value != ";") {
                location.methods.push_back(tokens[pos].value);
                pos++;
            }
            expectToken(tokens, pos, ";");
        } else if (tokens[pos].value == "cgi") {
            pos++;
            location.cgi_extension = tokens[pos].value;
            pos++;
            expectToken(tokens, pos, ";");
        } else {
            std::cerr << "Direttiva sconosciuta nel blocco location: " << tokens[pos].value << std::endl;
            pos++;
        }
    }
    expectToken(tokens, pos, "}");
    return location;
}
#include "Tokenizer.hpp"
#include <cctype>
#include <sstream>

Tokenizer::Tokenizer() {}
Tokenizer::~Tokenizer() {}

bool Tokenizer::isSymbol(char c) const {
    return (c == '{' || c == '}' || c == ';');
}

bool Tokenizer::isWhitespace(char c) const {
    return (c == ' ' || c == '\t' || c == '\n' || c == '\r');
}

std::vector<Token> Tokenizer::tokenize(const std::string &content) {
    std::vector<Token> tokens;
    size_t i = 0;
    while (i < content.size()) {
        if (isWhitespace(content[i])) {
            i++;
            continue;
        }
        // Se è un simbolo
        if (isSymbol(content[i])) {
            Token token;
            token.type = TOKEN_SYMBOL;
            token.value = content[i];
            tokens.push_back(token);
            i++;
            continue;
        }
        // Se è una parola o un numero (token alfanumerico)
        size_t start = i;
        while (i < content.size() && !isWhitespace(content[i]) && !isSymbol(content[i])) {
            i++;
        }
        std::string word = content.substr(start, i - start);
        Token token;
        // Possiamo migliorare il riconoscimento: se tutti i caratteri sono numerici, possiamo definirlo come TOKEN_NUMBER.
        bool isNum = true;
        for (size_t j = 0; j < word.size(); j++) {
            if (!std::isdigit(word[j])) {
                isNum = false;
                break;
            }
        }
        token.type = (isNum ? TOKEN_NUMBER : TOKEN_WORD);
        token.value = word;
        tokens.push_back(token);
    }
    return tokens;
}
#include "Parser.hpp"
#include "HTTPServer.hpp"
#include <fstream>
#include <iostream>
#include <sstream>

std::string readFile(const std::string &filename) {
    std::ifstream file(filename.c_str());
    if (!file.is_open()) {
        throw std::runtime_error("Impossibile aprire il file: " + filename);
    }
    std::stringstream buffer;
    buffer << file.rdbuf();
    return buffer.str();
}

int main(int argc, char **argv) {
    std::string configPath = "config/default.conf"; // percorso di default
    if (argc > 1) {
        configPath = argv[1];
    }

    try {
        std::string configContent = readFile(configPath);
        Parser parser;
        Config config = parser.parse(configContent);
        // Stampa di debug: direttive lette
        std::cout << "Numero di server configurati: " << config.servers.size() << std::endl;
        for (size_t i = 0; i < config.servers.size(); i++) {
            std::cout << "Server " << i+1 << ":\n";
            std::cout << "\tListen: " << config.servers[i].listen << "\n";
            std::cout << "\tHost: " << config.servers[i].host << "\n";
            std::cout << "\tServer Name: " << config.servers[i].server_name << "\n";
            std::cout << "\tError Page: " << config.servers[i].error_page << "\n";
            std::cout << "\tClient Max Body Size: " << config.servers[i].client_max_body_size << "\n";
            std::cout << "\tNumero di location: " << config.servers[i].locations.size() << "\n";
        }
        HTTPServer server(config);
        server.run();

    } catch (std::exception &e) {
        std::cerr << "Errore: " << e.what() << std::endl;
        return 1;
    }
    return 0;
}
